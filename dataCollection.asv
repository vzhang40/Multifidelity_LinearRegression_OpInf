%% Problem Set-Up
clear; close all; clc;

%% Data Collection
% Conditions
L = 1; % length
T = 1.5; % final time
deta = [2^-7, 2^-4]; % mesh width for discretization
dt = [10^-3, 10^-1]; % time step size
mu = 0.01; % thermal diffusivity
N = L./deta; % number of spatial grid points
K = T./dt; % number of time grid points

A = getAMatrix(N(1), mu);

x = linspace(0, L, N(1));
xl = linspace(0, L, N(2));
t = linspace(0, T, K(1)+1);
tl = linspace(0, T, K(2)+1);

timesteps = 1;

t = t(1:timesteps + 1);
tl = tl(1:2);

p = 6000; q = 20;
para = getRandIC(p, q);
x0 = getIC(x, para);
x0l = getIC(xl, para);
x0l = interp1(xl, x0l, x);

datah = zeros(N(1), p*q);
datahdot = zeros(N(1), p*q);
datal = zeros(N(1), p*q);
dataldot = zeros(N(1), p*q);
for i = 1:p*q
    Xhtemp = backwardEuler(A, x0(:, i), t);
    Xhdottemp = getDot(Xhtemp, t);
    Xhtemp = Xhtemp(:, 2:end);
    datah(:, i) = Xhtemp;
    datahdot(:, i) = Xhdottemp;

    Xltemp = backwardEuler(A, x0l(:, i), tl);
    Xltemp = interp1(tl, Xltemp', t)';
    Xldottemp = getDot(Xltemp, t);
    Xltemp = Xltemp(:, 2:end);
    datal(:, i) = Xltemp;
    dataldot(:, i) = Xldottemp;
    if mod(i, p*q./20) == 0
        disp("")
    end
    disp(i)
end

save("data" + num2str(timesteps) + ".mat","A","datah", "datahdot", "datal", "dataldot", "timesteps")

%% functions
function param = getRandIC(p, q)
% INPUTS: 
%   p : number of random amplitude parameters
%   q : number of random frequency parameters
% OUTPUTS: 
%   param : (2 x pq) parameters [a; b] assoicated with each intial
%       condition
    
    % Generating random amplitudes
    a = rand(p, 1);

    % Generating random frequencies
    b = randi(5, [q, 1]); %

    % parameters
    param = [repmat(a', 1, q); repelem(b', 1, p)];
    inds = randperm(p*q);
    param = param(:, inds);
end

function x0 = getIC(x, param)
% INPUTS: 
%   x : (N x 1) discretized spatial coordinate
%   param : (2 x pq) parameters [a; b] assoicated with each intial
%       condition
    x01 = param(1,:)'*sin(2.*pi.*x./x(end));
    x02 = cos(2*pi*param(2, :)'*x./x(end));
    x0 = (x01 + x02)';
end

function X_dot = getDot(X, t)
% This function uses a first order difference approximation to generate the
% time derivative state matrix X_dot
% INPUTS:
%   X - an (N x K) matrix representing the state
%   t - time vector
% OUTPITS:
%   X_dot - an (N x K-1) matrix representing the time derivative of the
%   state
    dt = t(2:end) - t(1:end-1);
    X_dot = (1./dt).*(X(:, 2:end) - X(:, 1:end-1));
end

function X = backwardEuler(A, x0, time)
    N = size(A, 1);
    K = length(time);
    X = zeros(N, K);
    X(:, 1) = x0; 
    % iterate through each time step
    for i = 1:K-1
        dt = time(i+1) - time(i);
        new_u = (eye(N) - dt*A)\(X(:, i));
        X(:, i+1) = new_u;
    end
end


function A = getAMatrix(N, mu)
% This is the operator matrix for the one-dimensional Heat Equation with
% periodic boundary conditions.
    dx = 1/(N + 1);
    A = (mu/dx^2)*(diag(-2*ones(N, 1), 0) + diag(ones(N-1, 1), -1) + diag(ones(N-1, 1), 1) + diag(1, -(N-1)) + diag(1, N-1));
end
